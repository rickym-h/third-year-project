<!DOCTYPE html>
<html lang="en">
<head>
    <title>Learn</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="w3styles.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata">
    <style>
        body, html {
            height: 100%;
            font-family: "Inconsolata", sans-serif;
        }

        .bgimg {
            background-position: center;
            background-size: cover;
            background-image: url("mountian-image.jpg");
            min-height: 75%;
        }

        /*.menu {*/
        /*  display: none;*/
        /*}*/
    </style>
    <script src="Perlin.js" defer></script>
    <script src="DemoHelperFunctions.js" defer></script>
    <script src="SetupLearnDemos.js" defer></script>
</head>
<body>

<!-- Links (sit on top) -->
<div class="w3-top">
    <div class="w3-row w3-padding w3-black">
        <div class="w3-col s3">
            <a href="index.html" class="w3-button w3-block w3-black">HOME</a>
        </div>
        <div class="w3-col s3">
            <a href="learn.html" class="w3-button w3-block w3-black">LEARN</a>
        </div>
        <div class="w3-col s3">
            <a href="demos.html" class="w3-button w3-block w3-black">DEMOS</a>
        </div>
        <div class="w3-col s3">
            <a href="pseudocode.html" class="w3-button w3-block w3-black">PSEUDOCODE</a>
        </div>
    </div>
</div>


<!-- Add a background color and large text to the whole page -->

<div class="w3-sand w3-grayscale w3-large">
    <!-- About Container -->
    <div class="w3-container" id="about">
        <div class="w3-content" style="max-width:700px">
            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">LEARN</span></h5>

            <p>Perlin Noise is procedural, deterministic, seeded, and can be expanded to an arbitrary number of dimensions.</p>
            <p>Procedural - The data is generated, meaning it was not created by a person. It is generated through code.</p>
            <p>Deterministic - Although generated through code and is seemingly random, the data can be repeatable if the starting conditions are the same. This means you can generate the same values again if you want to.</p>
            <p>Seeded - This is what actually makes the randomness deterministic. You can provide a ‘seed’ - usually a number of some kind, which will then be used to generate the noise. If the same number is used again in the future, the exact same set of numbers will be generated!</p>
            <p>Dimensions - The dimensions basically mean how many directions are the numbers  generated in? In 1-D the numbers can go left and right. In 2-D the numbers can go left, right, up and down. Perlin noise however can be applied to any number of dimensions; 3-D, 4-D, even 100-D if you wanted to!</p>

            <div class="DemoHolder">
                <button id="demo_2DPerlin:GenerateNoise">Generate Noise</button>
                <canvas id='demo_2DPerlin' width="512" height="512"></canvas>
            </div>


            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">HOW DOES IT WORK?</span></h5>

            <p>There are four main steps to generating Perlin Noise, which must be applied one after the other. Some different implementations might do some parts slightly differently, depending on the use case of the noise, but we will talk about these later.</p>
            <p>The main parts are Generating Grid Vectors, Creating Candidate Point Vectors, Calculating Dot Products, and finally Interpolation.</p>

            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">GRID VECTORS</span></h5>
            <p>The first step is to create a grid of vectors, where each vector points in a random direction. A vector is basically an arrow with a magnitude (length) and a direction. The important thing about these vectors though, is that they must all have a magnitude of 1. This is what we call a ‘normalised’ vector, where the length is ‘unit length’.</p>
            <p>For our example of generating a 2D heightmap, you might imagine the vectors as arrows with a length of 1, pointing in any direction in a circle (360 degrees). This grid must be a lower resolution than the final perlin noise wanted. For example if you wanted some Perlin Noise to fill a 1000x1000 grid, you might only have a 50x50 grid of vectors. This ratio would be adjusted depending on the use case.</p>
            <p>[demo for grid vectors]</p>

            <div class="DemoHolder">
                <button id="demo_GridVectors:NewGrid">Re-generate grid</button>
                <canvas id='demo_GridVectors' width="512" height="512"></canvas>
            </div>

            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">Candidate Point Vectors</span></h5>
            <p>The next step is to calculate vectors to what we call the candidate points. These are the actual positions of the values for perlin noise we want to generate. In some cases, it might be good to imagine the grid of vectors as a coordinate system, and each of our candidate points sits in between the coordinate grid. At each vertex of our coordinate grid there is a random normalised vector.</p>
            <p>For example our candidate point might be at (1.3, 0.4), and it is surrounded by the grid vectors at coordinates (1,0), (1,1), (2,0), (2,1). Each of these 4 grid points have an associated random unit vector from the previous step, but we won't worry about these until the next step.</p>
            <p>The Candidate Point Vectors are the vectors which will point at the candidate point from each of the surrounding grid points. The number of these vectors needed also depends on the number of dimensions we are generating Perlin Noise for. For example, on a 2D plane there are 4 surrounding grid vertices (forming a square surrounding the point), but in 3D space there would be 8 surrounding grid vertices (forming a cube surrounding the point).</p>
            <p>Each of these surrounding vertices has a vector created which points towards the candidate point. Now, each candidate point has 4 surrounding normalised grid vectors, and 4 surrounding candidate point vectors (in 3D this would be 8 each, in 4D it would be 16 each, in 5D space it would be 32 each etc).</p>
            <p>[demo for candidate point vectors]</p>

            <div class="DemoHolder">
                <button id="demo_CandidatePointVectors:PickCoord">Pick New Co-ordinate (or click in the square!)</button>
                <p>Candidate Point: <span id="demo_CandidatePointVectors:PointCoord"></span></p>
                <p>Vector A (Top Left): <span id="demo_CandidatePointVectors:A"></span></p>
                <p>Vector B (Top Right): <span id="demo_CandidatePointVectors:B"></span></p>
                <p>Vector C (Bottom Left): <span id="demo_CandidatePointVectors:C"></span></p>
                <p>Vector D (Bottom Right): <span id="demo_CandidatePointVectors:D"></span></p>
                <canvas id='demo_CandidatePointVectors' width="512" height="512"></canvas>
            </div>

            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">Dot Product</span></h5>
            <p>At this point for every candidate point, each surrounding grid vertex has two associated vectors; one random unit vector, and one vector which points from the vertex to the candidate point.</p>
            <p>We want to calculate the dot product between these two vectors. This is a mathematical process to give us a single number from two vectors of any length (as long as the two vectors have the same number of dimensions).</p>
            <p>This is a simple computation - just multiply each value against the equivalent value in the other vector and then add them all up!</p>


            <div class="DemoHolder">
                <p>Vector A:
                    <label for="demo_DotProduct:Ax">x:</label>
                    <input id="demo_DotProduct:Ax" type="number" min="-1" max="1" step="0.05" value="-0.5" onchange="UpdateDotProductDemo()">
                    <label for="demo_DotProduct:Ay">y:</label>
                    <input id="demo_DotProduct:Ay" type="number" min="-1" max="1" step="0.05" value="0.5" onchange="UpdateDotProductDemo()">
                </p>
                <p>Vector B:
                    <label for="demo_DotProduct:Bx">x:</label>
                    <input id="demo_DotProduct:Bx" type="number" min="-1" max="1" step="0.05" value="0.5" onchange="UpdateDotProductDemo()">
                    <label for="demo_DotProduct:By">y:</label>
                    <input id="demo_DotProduct:By" type="number" min="-1" max="1" step="0.05" value="0.5" onchange="UpdateDotProductDemo()">
                </p>
                <p id="demo_DotProduct:RangeWarning">Warning - Vector values must be in the range -1 -> 1</p>
                <p>Dot Product: <span id="demo_DotProduct:DotProduct"></span></p>
                <canvas id='demo_DotProduct' width="512" height="512"></canvas>
            </div>

            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">Interpolation</span></h5>
            <p>The final step in the process is to interpolate between each of the surrounding values. This is sort of ‘averaging out’ the values around it. However, it is not as simple as just finding the mean of the values. Interpolation is finding a value in between two numbers, but it can be weighted to either side. </p>
            <p>[interpolation demo?]</p>
            <p>In our case we want to weight the values based on how close the candidate point is to the grid vertex. In our 2D example, we have 4 points, which we need to interpolated both in the x and y direction.</p>
            <p>[2d interpolation demo?]</p>
            <p>Most interpolation with perlin noise often doesn’t use what we call a ‘linear’ interpolation’ as shown above. More often than not, we use a smoother interpolation function; a common one is Smoothstep.</p>
            <p>[image of different interpolations on a graph]</p>
            <p>Finally, we should have one single value for our candidate point. This is a floating point value, and represents the value of the noise at this position in space.</p>
            <p>This value can then be mapped to whatever usage we want! Here we have a demo where some 2D noise has been generated and used as a heightmap, and depending on the value we have assigned a colour. </p>
            <p>[heightmap demo]</p>

            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">Example Walkthrough</span></h5>
            <p>[example walkthrough]</p>
            <p></p>

            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">Extended Implementations</span></h5>
            <h5 class="w3-center w3-padding-64"><span class="w3-tag w3-wide">Fractal Noise</span></h5>
            <p></p>
            <p></p>



            <div class="DemoHolder">
                <table class="optionContainer">
                    <tr class="optionSlider">
                        <td><label for="demo_final:OctaveSlider" class="optionLegend">Octave: <span id="demo_final:OctaveValue"></span></label></td>
                        <td><input type="range" min="1" max="5" value="3" class="slider" id="demo_final:OctaveSlider"></td>
                    </tr>
                    <tr class="optionSlider">
                        <td><label for="demo_final:CellCountSlider" class="optionLegend">Cell Count: <span id="demo_final:CellCountValue"></span></label></td>
                        <td><input type="range" min="1" max="8" value="4" class="slider" id="demo_final:CellCountSlider"></td>
                    </tr>
                    <tr class="optionSlider">
                        <td><label for="demo_final:CellResSlider" class="optionLegend">Cell Resolution: <span id="demo_final:CellResValue"></span></label></td>
                        <td><input type="range" min="1" max="7" value="5" class="slider" id="demo_final:CellResSlider"></td>
                    </tr>
                    <tr class="optionSlider">
                        <td><label for="demo_final_ShowGrid" class="optionLegend">Show Grid: <span id="demo_final:ShowGridValue"></span></label></td>
                        <td><input type="checkbox" checked id="demo_final_ShowGrid"></td>
                    </tr>
                </table>
                <button id="demo_final:GenerateHeightMap">Generate Heightmap</button>
                <canvas id='demo_final' width="512" height="512"></canvas>
            </div>


        </div>
    </div>


    <!-- End page content -->
</div>
<!-- Footer -->
<footer class="w3-center w3-light-grey w3-padding-48 w3-large">
    <p>Created by <a href="https://github.com/rickym-h" title="W3.CSS" target="_blank" class="w3-hover-text-green">Richard Hull</a></p>
</footer>


</body>
</html>
